import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from numpy import random
import math
import scipy.special

# Size of Sub-level L(i,j)
def Size_Of_Sublevel(i,j):
    return (j+1)*(i+1)

# Position of state (s,id,iw,ic) in its sublevel L(s+id,iw+ic). First position is position=0
def Position_State(s,iD,iW,iC):
    return s*(iW+iC+1)+iW

# Sum of rates
def Delta(s,iD,iW,iC):
    return delta*iD+phiD*betaC*s*iC+(betaW*iW+phiW*betaC*iC)*s+betaC*(1-phiW)*iW*iC+betaC*(1-phiW-phiD)*s*iC+(betaC*(1-phiD)*iC+betaW*iW)*iD+rhoW*iW+rhoC*iC

N=12
delta=8
betaW=2/N #Transmission rate * N for that dataset
betaC=9 #Assume some effect on transmission rate
phiW=0.25
phiD=0.25
#epsilon = probability of recovery
#epsilonw = probability of death
epsilonw = 0.1 #Start with adult population
epsilon= 1-epsilonw
epsilonc = epsilonw/3 #Assume some effect on death probability due to DIP presence
eta= 1-epsilonc
rhoW=1
rhoC=1 #Assumed no effect on length of infection from DIP


# Define vectors {\bar R}_{i,j}, for i=0,...,N; j=0,...,N-i. Initialised at all-zeros
def Means(delta,betaC):
    mean_R=[[np.asmatrix(np.zeros((Size_Of_Sublevel(i,j),1))) for j in range(N-i+1)] for i in range(N+1)]
    
    for iW in range(N+1):
        for iC in range(N-iW+1):
            if iW+iC==0:
                mean_R[0][0][Position_State(0,0,iW,iC),0]=0
            else:
                if iW>0:
                    mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=betaC*(1-phiW)*iW*iC*mean_R[0][iW+iC][Position_State(0,0,iW-1,iC+1),0]
                    mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=(1-epsilon)*rhoW*iW*mean_R[0][iW+iC-1][Position_State(0,0,iW-1,iC),0]
                    mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=epsilon*rhoW*iW*(mean_R[0][iW+iC-1][Position_State(0,0,iW-1,iC),0]+1)
                if iC>0:
                    mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=(1-eta)*rhoC*iC*mean_R[0][iW+iC-1][Position_State(0,0,iW,iC-1),0]
                    mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=eta*rhoC*iC*(mean_R[0][iW+iC-1][Position_State(0,0,iW,iC-1),0]+1)
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]=mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]/Delta(0,0,iW,iC)
    
    b=[[np.asmatrix(np.zeros((Size_Of_Sublevel(i,j),1))) for j in range(N-i+1)] for i in range(N+1)]
    A=[[np.asmatrix(np.zeros((Size_Of_Sublevel(i,j),Size_Of_Sublevel(i,j)))) for j in range(N-i+1)] for i in range(N+1)]
    
    
    for i in range(1,N+1):
        j=0
        for s in range(i+1):
            iD=i-s
            iW=0
            iC=0
            mean_R[i][j][Position_State(s,iD,iW,iC),0]=0
        for j in range(1,N-i+1):
            for s in range(i+1):
                iD=i-s
                for iW in range(j+1):
                    iC=j-iW
                    if iD>0:
                        A[i][j][Position_State(s,iD,iW,iC),Position_State(s+1,iD-1,iW,iC)]=delta*iD/Delta(s,iD,iW,iC)
                    if s>0:
                        A[i][j][Position_State(s,iD,iW,iC),Position_State(s-1,iD+1,iW,iC)]=betaC*phiD*s*iC/Delta(s,iD,iW,iC)
                    if iW>0:
                        A[i][j][Position_State(s,iD,iW,iC),Position_State(s,iD,iW-1,iC+1)]=betaC*(1-phiW)*iW*iC/Delta(s,iD,iW,iC)
                    if s>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=(betaW*iW+phiW*betaC*iC)*s*mean_R[i-1][j+1][Position_State(s-1,iD,iW+1,iC),0]
                        b[i][j][Position_State(s,iD,iW,iC),0]+=betaC*(1-phiW-phiD)*s*iC*mean_R[i-1][j+1][Position_State(s-1,iD,iW,iC+1),0]
                    if iD>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=iD*(betaC*(1-phiD)*iC+betaW*iW)*mean_R[i-1][j+1][Position_State(s,iD-1,iW,iC+1),0]
                    if iW>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=(1-epsilon)*rhoW*iW*mean_R[i][j-1][Position_State(s,iD,iW-1,iC),0]
                    if iW>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=epsilon*rhoW*iW*(mean_R[i][j-1][Position_State(s,iD,iW-1,iC),0]+1)
                    if iC>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=(1-eta)*rhoC*iC*mean_R[i][j-1][Position_State(s,iD,iW,iC-1),0]
                    if iC>0:
                        b[i][j][Position_State(s,iD,iW,iC),0]+=eta*rhoC*iC*(mean_R[i][j-1][Position_State(s,iD,iW,iC-1),0]+1)
                    b[i][j][Position_State(s,iD,iW,iC),0]=b[i][j][Position_State(s,iD,iW,iC),0]/Delta(s,iD,iW,iC)
            mean_R[i][j]=np.linalg.solve(np.eye(Size_Of_Sublevel(i,j))-A[i][j],b[i][j])
    
    """print("Mean values of R\n")
    for i in range(N+1):
        #print("i:",i)
        for j in range(N-i+1):
            #print(mean_R[i][j])
    """
    return mean_R
print("End")
mean_R = Means(delta,betaC)
def Matrix_Getter(x):
    A = np.zeros((N+1,N+1))
    for i in range(N+1):
        for j in range(N+1):
            if i + j < x[2]+x[3]:
                continue
            elif i + j > N:
                A[i,j] = np.NAN
            else:
                A[i,j] += mean_R[x[0]+x[1]][x[2]+x[3]][Position_State(x[0],x[1],x[2],x[3])]
    A[0,0] = np.NAN
    return A

IDs = ["25%","50%","75%"]
ISs = [[round(N*0.75-1),round(N*0.25)],[round(N*0.5-1),round(N*0.5)],[round(N*0.25-1),round(N*0.75)]]
print(delta)
print(betaC)
deltas=[1/1,1/2,1/4]
betaCs = [betaW,2*betaW/3,betaW/3]
def Info_Getter(x):
    A = np.zeros((3,3))
    B = np.zeros((3,3))
    C = np.zeros((3,3))
    D = np.zeros((3,3))
    E = np.zeros((3,3))
    F = np.zeros((3,3))
    X = []
    for i in range(3):
        delta = deltas[i]
        print(delta)
        for j in range(3):
            betaC = betaCs[j]
            print(betaC)
            M = Means(delta,betaC)
            X.append(M)
            A[i,j] += M[N-1][1][Position_State(x[0][0],x[0][1],1,0)]
            B[i,j] += M[N-1][1][Position_State(x[1][0],x[1][1],1,0)]
            C[i,j] += M[N-1][1][Position_State(x[2][0],x[2][1],1,0)]
            D[i,j] += M[N-1][1][Position_State(x[0][0],x[0][1],0,1)]
            E[i,j] += M[N-1][1][Position_State(x[1][0],x[1][1],0,1)]
            F[i,j] += M[N-1][1][Position_State(x[2][0],x[2][1],0,1)]
    return A,B,C,D,E,F,X
    
ms = Info_Getter(ISs)


Matrix_Getter([2,0,2,1])
"""
# Algorithm 3
        
delta=0

mean_R=[[np.asmatrix(np.zeros((Size_Of_Sublevel(i,j),1))) for j in range(N-i+1)] for i in range(N+1)]

for iW in range(N+1):
    for iC in range(N-iW+1):
        if iW+iC==0:
            mean_R[0][0][Position_State(0,0,iW,iC),0]=0
        else:
            if iW>0:
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=betaC*(1-phiW)*iW*iC*mean_R[0][iW+iC][Position_State(0,0,iW-1,iC+1),0]
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=(1-epsilon)*rhoW*iW*mean_R[0][iW+iC-1][Position_State(0,0,iW-1,iC),0]
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=epsilon*rhoW*iW*(mean_R[0][iW+iC-1][Position_State(0,0,iW-1,iC),0]+1)
            if iC>0:
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=(1-eta)*rhoC*iC*mean_R[0][iW+iC-1][Position_State(0,0,iW,iC-1),0]
                mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]+=eta*rhoC*iC*(mean_R[0][iW+iC-1][Position_State(0,0,iW,iC-1),0]+1)
            mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]=mean_R[0][iW+iC][Position_State(0,0,iW,iC),0]/Delta(0,0,iW,iC)

for i in range(1,N+1):
    j=0
    for s in range(i+1):
        iD=i-s
        iW=0
        iC=0
        mean_R[i][j][Position_State(s,iD,iW,iC),0]=0
    for j in range(1,N-i+1):
        for iD in reversed(range(i+1)):
            s=i-iD
            for iW in range(j+1):
                iC=j-iW
                if s>0:
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=phiD*betaC*s*iC*mean_R[i][j][Position_State(s-1,iD+1,iW,iC),0]
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=(betaW*iW+phiW*betaC*iC)*s*mean_R[i-1][j+1][Position_State(s-1,iD,iW+1,iC),0]
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=betaC*(1-phiD-phiW)*s*iC*mean_R[i-1][j+1][Position_State(s-1,iD,iW,iC+1),0]
                if iW>0:
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=betaC*(1-phiW)*iW*iC*mean_R[i][j][Position_State(s,iD,iW-1,iC+1),0]
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=(1-epsilon)*rhoW*iW*mean_R[i][j-1][Position_State(s,iD,iW-1,iC),0]
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=epsilon*rhoW*iW*(mean_R[i][j-1][Position_State(s,iD,iW-1,iC),0]+1)
                if iD>0:
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=(betaC*(1-phiD)*iC+betaW*iW)*iD*mean_R[i-1][j+1][Position_State(s,iD-1,iW,iC+1),0]
                if iC>0:
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=(1-eta)*rhoC*iC*mean_R[i][j-1][Position_State(s,iD,iW,iC-1),0]
                    mean_R[i][j][Position_State(s,iD,iW,iC),0]+=eta*rhoC*iC*(mean_R[i][j-1][Position_State(s,iD,iW,iC-1),0]+1)
                mean_R[i][j][Position_State(s,iD,iW,iC),0]=mean_R[i][j][Position_State(s,iD,iW,iC),0]/Delta(s,iD,iW,iC)

print("Mean values of R\n")
for i in range(N+1):
    print("i:",i)
    for j in range(N-i+1):
        print(mean_R[i][j])

print("End")
"""